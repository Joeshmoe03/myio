Loremipsumdolorsitamet,consecteturadipiscing elit, sed do eiusmod 

/*myio.c*/
#include <stdio.h>
#include <fcntl.h>
#include <sys/stat.h>
#include "myio.h"
#include <stdlib.h>

#define BUFFER_SIZE 4096

//myopen returns struct
//myread(FILE, *buf, count)

//close call flush
//write call flush?

MYFILE *myopen(const char* path, int flags) { 
	int filedesc;
    
	/* MYFILE is a struct that we made in myio.h: contains relevant info to our file and corresponding buffer */
	MYFILE *filep = malloc(sizeof(MYFILE));
	
	//TODO: HANDLE OUR FLAGS //

	
	/*** READING IS IMPORTANT!!!
	The argument flags must include one of the following access
    //    modes: O_RDONLY, O_WRONLY, or O_RDWR.  These request opening the
    //    file read-only, write-only, or read/write, respectively.

    //    In addition, zero or more file creation flags and file status
    //    flags can be bitwise-or'd in flags.  The file creation flags are
    //    O_CREAT, O_TRUNC  ***/


	// switch(flags) {
	// 	case O_CREAT:
	// 		filedesc = open(path, O_CREAT, 0666); //TODO
	// 		break;
	// 	case O_WRONLY:
	// 		filedesc = open(path, O_WRONLY); //TODO
	// 		break;
	// 	case O_RDONLY:
	// 		filedesc = open(path, O_RDONLY); //TODO
	// 		break;
	// 	case O_RDWR:
    //         //printf("INSIDE\n");
	// 		filedesc = open(path, O_RDWR); //TODO
	// 		break;
	// 	case O_TRUNC:
	// 		filedesc = open(path, O_TRUNC, 0666); //TODO
	// 		break;
	// 	default:
	// 		//printf("in default");
    //         perror("open");
	// 		break;


		//flags
			//include access modes

		
		// if O_RDONLY
		// 	open(1 | Rest of non-access mode flags)
		// if 2

		// if 3


		// if (no access modes are provided) {
		// 	fail
		// }

		
		



	
        // if (flags == O_CREAT || flags == O_TRUNC) {
        //     open(path, flags, 0666);
        // }

		//is this not enough, will give us error messages and stuff
        open(path, flags);
		
		void* filebuff = malloc(BUFFER_SIZE); //TODO: IS THIS CORRECT TYPE? SHOULD WE EVEN DO HERE?

		filep->filedesc = filedesc;
		filep->buff = filebuff;
		filep->buffsize = BUFFER_SIZE;
		filep->offset = 0;
		filep->useroffset = 0;
		//TODO: ANY OTHER STRUCT ELEMENTS?
	
	return filep;
}


/*
 * mytestmyio.c
 */

#include <stdio.h>
#include <fcntl.h>
#include <sys/syscall.h>
#include <unistd.h>
#include "myio.h"

int
main(int argc, char *argv[])
{
    //printf("%d\n", myopen("hello.txt", O_RDWR | O_RDONLY | O_WRONLY | O_CREAT | O_TRUNC));
    //perror("open");
    //printf("Worked?\n");
    
    
   // myopen("hello.txt", O_RDWR);
    MYFILE *f1 = myopen("hello.txt", O_RDWR);
    perror("open");

    char buf[4096];
    // char buf2[10240];

    printf("%d",f1->filedesc);
    // //read((f1->filedesc), buf, 4096);

    // // int try1 = open("hello.txt", O_RDWR);
    // // perror("open");

    // // read(try1, buf2, 10240);
    // // perror("read");

    // printf(buf);
    // printf(buf2);

}


/*Myread*/
	// while(filep->bufcount < filep->bufsize) {

	// 	//IF IT'S EMPTY (first call or we emptied it out by reading all of it into userbuffer)
	// 	//DO read() call into OUR BUFFER IN STRUCT
	// 	if(filep->bufcount == 0) {
	// 		read((filep -> filedesc), filep->buf, filep->bufsize);
	// 	}

	// 	//CASE1 (ask for more or same than we have)
	// 	// if they desire to read more bytes than our buffer can allocate, just give them all we got 
	// 	if (bytesleft >= filep->bufsize) {
	// 		memcpy(userbuffer, filep->buf, filep->bufsize); //gives them what we got (buffer size)
	// 		//reset
	// 		free(filep->buf);
	// 		filep->buf = trycharmalloc(filep->bufsize);
	// 		count -= filep->bufsize;
	// 		continue;
	// 	}

	// 	//else (count < bytesleft), give them only what they need (until our buffer is emptied - reached )
	// 	memcpy(userbuffer, filep->buf, bytesleft);
	// 	filep->bufcount += bytesleft;
		
	// }


	// if
	// //CASE2 (ask for less than we have)
	// memcpy(userbuffer, filep->buf, count);
	// filep->bufcount += count;
	


	//work with two separate cases, more or less


	// //IF IT'S EMPTY (first call or we emptied it out by reading all of it into userbuffer)
	// //DO read() call into OUR BUFFER IN STRUCT
	// if(filep->bufcount == 0) {
	// 	read((filep -> filedesc), filep->buf, filep->bufsize);
	// }

	// //while we haven't emptied IT (or it's not full); idk some condition
	// //memcpy according to user's read call
	// while(filep->bufcount <= filep->bufsize) {

	// 	// //if they desire to read more bytes than our buffer can allocate, just give them all we got 
	// 	// if (count > filep->bufsize) {
	// 	// 	memcpy(userbuffer, filep->buf, filep->bufsize); //gives them what we got (buffer size)
	// 	// 	free(filep->buf);
	// 	// 	filep->buf = trycharmalloc(filep->bufsize);
	// 	// 	filep->bufcount += filep->bufsize;
	// 	// 	continue;
	// 	// }

	// 	memcpy(userbuffer, filep->buf, count);
	// 	filep->bufcount += count;
	// }

	// //once we unload all of our read bytes in buffer, empty it, reset 
	// free(filep->buf);

	// filep->buf = trycharmalloc(filep->bufsize);
	// filep->bufcount = 0;


	// //read with bytesleft or go in one last time in other loop
	// read((filep -> filedesc), filep->buf, bytesleft);
	// memcpy(userbuffer+50, filep->buf, bytesleft);
	// printf(userbuffer+50);
	// printf("\n\n");
	// filep->bufcount += bytesleft;


	// //if they desire to read more bytes than our buffer can allocate, just give them all we got (rinse and repeat until we go into case 2) 
	// while(bytesleft + filep->bufcount >= filep->bufsize) { //will catch the case when we ask for more than we have available (read(10) with only 5 empty spaces)
	// 	if(filep->bufcount == 0) {
	// 		printf("We reading\n");
	// 		//read() gives 0 for EOF and is negative for error n 
	// 		if(read((filep -> filedesc), filep->buf, filep->bufsize) <0) {
	// 			perror("read");
	// 			exit(1);	
	// 		}		
	// 	}

	// 	printf("We unloading\n");
	// 	memcpy(userbuffer, filep->buf, filep->bufsize); //gives them what we got (buffer size); causes memory leaks
	// 	printf(userbuffer); //associated with memory leaks;
	// 	printf("\n\n");
	// 	//reset (overwrites implicitly so no need to do this??)
	// 	// free(filep->buf);
	// 	// filep->buf = trycharmalloc(filep->bufsize);
	// 	bytesleft -= filep->bufsize;
	// }

	//else (count < bytesleft), give them only what they need (until our buffer is emptied - reached ) or should i let case 2 handle this?
	//printf("%d\n",  bytesleft);

	//reset (overwrites implicitly so no need to do this??)
	// free(filep->buf);
	// filep->buf = trycharmalloc(filep->bufsize);

	//printf("Final unload\n");
